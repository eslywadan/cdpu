from flask import request, make_response, redirect, url_for
import requests
import urllib.parse as urltool
from dpam.tools.config_loader import ConfigLoader
from dpam.tools.logger import Logger
from dsbase.tools.redis_db import RedisDb
import json
import os
from datetime import datetime
import re
from dpam.tools.get_env import env

"""
    The environment variable 'api_account_env' has 'tst'|'prd' values. The'validate_user' function detects the value for seperating used sso server.
"""
print(f"current env is set as {env}")

_api = { "v4_tst_vtt":  "https://tsamv4athe.cminl.oa/api/SSO/VerifyToken", 
         "v4_tst_lgn":  "https://tsamv4athe.cminl.oa/form/Logon.html", 
         "v4_prd_vtt":  "http://psamv4athetn.cminl.oa/api/SSO/VerifyToken",
         "v4_prd_lgn":  "http://psamv4athetn.cminl.oa/form/Logon.html",
         "v3_prd_vtt":  "http://inlcnws.cminl.oa/InxSSOv3/VerifyTicket.ashx",
         "v3_prd_lgn":  "http://inlcnws.cminl.oa/InxSSOv3/Logon.aspx"}

def resp_check():
    """
    request with corret requests format while fake content only to check the response code by vtt (verify ticket)
    """
    token = "IamAFaketOken"
    v4_headers =  {"Content-Type":"application/json"}
    v4_data = {
        "Token": token,
        "IsCheckIP": False,
        "SysID": "datastudio"
    }
    for srv_, url_ in _api.items():
        response = None
        if re.match(r'^v4.*vtt$',srv_):
            response = requests.post(url=url_, json=v4_data, headers=v4_headers)
        if re.match(r'^v3.*vtt$',srv_):
            response = requests.get(url_ + "?ticket=" +  urltool.quote_plus(token))
        if (response is not None) and (response.status_code in [200, 400, 401]):
            os.environ[srv_] = f"ok@{datetime.now().strftime('%Y/%m/%d:%H:%M:%S')}"
        else:
            os.environ[srv_] = f"fail@{datetime.now().strftime('%Y/%m/%d:%H:%M:%S')}"
        if response is not None:
            Logger.log(f"sso service {srv_} check {url_} response {response} at {datetime.now().strftime('%Y/%m/%d:%H:%M:%S')}")

def  validate_user(token_required=False,token=None):
    """
    The function applies stepwise aproach for ensuring correct user info.
    
    - A valid cookie store the sess_key that is used for fetching the user's info stored in UserSessions.
    - token passed with the request (request.args), the validating will forward the token to sso for vefification.
    - If none of above, it will re-direct user to sso login page to get the valid certificate|token and re-direct to validating page  
    
    The practical steps will be case when index page is reached, it will be forced to sso login page and redirect back with Token.

    Rule 1: If the function is called by Index page without Token, it will be redirect to sso's login page. The login page will redirect back to index page with user's Token.

    Rule 2: If the function is not called by index page, it will check the user's cookie

    Once login sucessfully, the app will set the cookie and stored the sess_key by the name. 
    
    cookie is the info can be set and reached by app, thus can be traced and used for
    recognizing interactions between app and the user's client.
    The cookie name's value store the sess_key that is the key to the user's session.
    So the 1st step of validate_user will chek if exist the valid sess_key.
    The 'sess_key' is a segment of the Token ( [-25:-5]) generated by the ssov4. 
    If a user is passing the Token as an argument via the request, validate_user will 
    get the Token and pass it to ssov4 to do verification. If ssov4 has verified the Toeken and 
    recognize it is valid, ssov4 will redirect the user's page to where the validate_user has designated.
    Or it will let user keying the id and password for authenticating.  
    """
    if env != 'prd': log_request_header()
    
    if token_required and token is not None: 
        Logger.log(f"step 00: token_required:{token_required} with given token {token}")
        return validate_user_ssov4(token=token)
    
    if token_required and "Token" in request.args.keys(): 
        Logger.log(f"step 02: token_required:{token_required} with Token {request.args['Token']}")
        return validate_user_ssov4()
    
    if token_required and "Token" not in request.args.keys(): 
        Logger.log(f"step 01: token_required:{token_required} without Token")
        return (None, None)
    
    sess_key = get_session_key()                        # get the sess_key from the client's cookie
    Logger.log(f"step 03: token_required:{token_required} sess_key: {sess_key}")
    if sess_key is None: 
        Logger.log(f"step 03-1 sess_key: {sess_key}")
        return validate_user_ssov4()
    if sess_key is not None: 
        user_id = UserSessions.get_login_user(sess_key)     # check if session stored the user_info by the sess_key
        Logger.log(f"step 03-2 sess_key: {sess_key} / user_id: {user_id}")
        if user_id is None: return validate_user_ssov4()
        Logger.log(f"step 03-3 sess_key: {sess_key} / user_id: {user_id}")
    if user_id and sess_key is not None:
        Logger.log(f"step 03-4 : get user info from session - user_id:{user_id} \n sess_key: {sess_key} \n ")
        return (user_id,sess_key)
    else:
        Logger.log(f"End of step 03: validate_user step unknown 0: please varify what is the condtion \n available info token_required:{token_required} \n request.args.keys: {request.args.keys()} \n sess_key : {sess_key} \ user_id: {user_id}") 
        return redirect_to_login()

def log_request_header():
    request_detail = f"accept_charsets: {request.accept_charsets} \n accept_encodings: {request.accept_encodings} \n"
    request_detail += f"accept_languages: {request.accept_languages} \n accept_mimetypes: {request.accept_mimetypes} \n"
    request_detail += f"access_control_request_headers :{request.access_control_request_headers} \n" 
    request_detail += f"access_control_request_method:{request.access_control_request_method} \n"
    request_detail += f"access_route:{request.access_route}\n application:{request.application} \n"
    request_detail += f"args:{request.args} \n authorization:{request.authorization} \n"
    request_detail += f"base_url:{request.base_url} \n"
    request_detail += f"blueprint:{request.blueprint} \n"
    request_detail += f"blueprints:{request.blueprints} \n"
    request_detail += f"cache_control:{request.cache_control} \n"
    request_detail += f"headers:{request.headers} \n"
    request_detail += f"server:{request.server} \n"
    request_detail += f"environ:{request.environ} \n"
    request_detail += f"endpoint:{request.endpoint}\n"
    request_detail += f"cookies :{request.cookies}\n"
    request_detail += f"content_encoding:{request.content_encoding}\n"
    Logger.log(request_detail)

def validate_user_ssov4(user_id=None, sess_key=None, token=None):
    """
    use environ to know the 'prod' or 'test' environment setting and use 'prod' as the default setting.
    1. user_id exist in UserSessions and the sess_key is match with Token
    2. user_id exist in UserSessions (_sesses or redis cache), but the sess_key is not match with Token
    3. user_id does not exist in UserSessions
    """
    ask_sso = False
    
    if user_id is None and token is not None:
        Logger.log(f"Use sso v4/cert_key: {token}")
        verify_url = _api[f"v4_{env}_vtt"]
        data = {
            "Token": token,
            "IsCheckIP": False,
            "SysID": "datastudio"
        }
        headers= {"Content-Type":"application/json"}
        url = verify_url
        response = requests.post(url=url, json=data, headers=headers)
        ask_sso = True
        Logger.log(f"validate_user use ssov4 step 0: 'Token' is given - user_id:{user_id} \n sess_key: {sess_key} \n cert_key:{token}\n")

    if user_id is None and "Token" in request.args:
        token = request.args["Token"]
        Logger.log(f"Use sso v4/cert_key: {token}")
        verify_url = _api[f"v4_{env}_vtt"]
        data = {
            "Token": token,
            "IsCheckIP": False,
            "SysID": "datastudio"
        }
        headers= {"Content-Type":"application/json"}
        url = verify_url
        response = requests.post(url=url, json=data, headers=headers)
        ask_sso = True
        Logger.log(f"validate_user use ssov4 step 1: 'Token' exist in request.args - user_id:{user_id} \n sess_key: {sess_key} \n cert_key:{token}\n")
    
    if ask_sso and response.status_code == 200:
        sess_key = token[-25:-5]
        ticket = response.json()
        Logger.log(f"response ticket: {ticket}")
        user_id = ticket["AD"]
        UserSessions.add_login_user(sess_key, user_id, ticket["MemID"])
        Logger.log(f"validate_user step 2: token:{token}\n url: {url} \n user_id:{user_id} \n sess_key: {sess_key} ")
    
    elif ask_sso and response.status_code != 200: Logger.log(f"validate_user step 2: status_code: {response.status_code} \n response_text: {response.text} \n cert_key:{token}\n url: {url} \n user_id:{user_id} \n sess_key: {sess_key} ")
    Logger.log(f"End of validate user: user_id: {user_id} / sess_key:{sess_key}")
    return (user_id, sess_key)

def redirect_to_login():    
    sso_login_url = _api[f"v4_{env}_lgn"]
    myhost = request.base_url
    Logger.log(f"myhost : {myhost}")
    url = sso_login_url + f"?SysID=datastudio&url={myhost}"
    Logger.log(f"redirect url:{url}")
    return redirect(url)

def validate_user_ssov3():
    sess_key = None
    user_id = UserSessions.get_login_user()
    if user_id is None and  "CertificateKey" in request.args:
        cert_key = request.args["CertificateKey"]
        verify_url = _api["v3_prd_vtt"]
        url = verify_url + "?ticket=" + urltool.quote_plus(cert_key)
        response = requests.get(url)
        if response.status_code == 200:
            sess_key = cert_key[-25:-5]
            ticket = response.json()
            UserSessions.add_login_user(sess_key, ticket["UserId"], ticket["EmpId"])
            user_id = ticket["UserId"]
    return (user_id, sess_key)

def redirect_to_login_ssov3():
    sso_login_url = _api["v3_prd_lgn"]
    url = sso_login_url + "?url=" + urltool.quote_plus(request.url)
    return redirect(url)

def write_session_cookie(response, sess_key):
    app_id = "api_account"
    name = "session_" + app_id
    response.set_cookie(name, sess_key)

def get_session_key():
    app_id = "api_account"
    name = "session_" + app_id
    return request.cookies.get(name)

#用來記錄/accounts_for_owner或/accounts_for_admin或/group_role_for_admin
def get_list_page():
    sess = UserSessions.get_session()
    return sess["list_page"] if sess is not None and "list_page" in sess else url_for('acct_bp.get_index_page')

#先簡單在這裡指定管理者，以後再按需求更改
def is_admin(user_id):
    admin = ConfigLoader.config("system")["admin"]
    return user_id in admin

class UserSessions:
    """"
    user's info is stored in UserSessions. UserSessions use redis for caching data and has two keys:
    key 1 has sess_key as the key and store the user_id and emp_id,
    key 2 has app_id@user_id as the key and store a dic type value.
    sess_key is kept in the user's cookie, it is a segment of the Token generated by ssov4. If the route page is index page, 
    it will force to do sync the sess_key with the token, or the sess_key store in the cookie will be valid unless it is volatile.  
    """
    import os
    if 'configpath' not in os.environ: os.environ['configpath'] = os.path.join(os.getcwd(),'config') 
    redis = RedisDb.default()
    redis_key_prefix = "session_api_account"
        
    _sessions = {}

    @classmethod
    def add_session(clz, sess_key):
        clz._sessions[sess_key] = {}
        return clz._sessions[sess_key]

    @classmethod
    def get_session(clz, sess_key=None):
        if sess_key is None: sess_key = get_session_key()
        if sess_key in clz._sessions: return clz._sessions[sess_key] 
        else:
            sess = clz._get_session_from_redis(sess_key)
            Logger.log(f"get session data from redis: sess_key {sess_key}, sess:{sess}")
            if sess is not None: 
                clz._sessions[sess_key] = sess
                Logger.log(f"set session data from redis: sess_key {sess_key}, clz._sessions:{sess}")
            return sess 
        
    @classmethod
    def clear_session(clz, sess_key=None):
        if sess_key is None: sess_key = get_session_key()
        if sess_key in clz._sessions: return clz._sessions.pop(sess_key)
        clz._del_session_from_redis(sess_key)

    @classmethod
    def add_login_user(clz, sess_key, user_id, emp_id):
        sess = clz.add_session(sess_key)
        sess["user_id"] = user_id
        sess["emp_id"] = emp_id
        clz.add_login_user_redis(sess_key, user_id, emp_id)

    @classmethod
    def get_login_user(clz, sess_key=None):
        if sess_key is None: sess_key = get_session_key()
        if sess_key is not None: sess = clz.get_session(sess_key)
        return sess["user_id"] if sess is not None and "user_id" in sess else None
    
    @classmethod
    def add_login_user_redis(clz, sess_key, user_id, emp_id):
        clz.redis.set(sess_key, json.dumps({"user_id":user_id,"emp_id":emp_id}))
        key = f"{clz.redis_key_prefix}@{user_id}"
        update_content = {"sess_key":sess_key,"emp_id":emp_id}
        origin_content = clz.redis.get(key)
        if origin_content is None or 'null' : content = update_content
        else: 
            content = json.loads(origin_content)
            content.update(update_content)
        clz.redis.set(key,json.dumps(content))

    @classmethod
    def update_login_user_redis(clz, user_id, **kwargs):
        key = f"{clz.redis_key_prefix}@{user_id}"
        origin_text = clz.redis.get(key)
        if origin_text is None : origin_content = {}
        else: origin_content = json.loads(origin_text)
        origin_content.update(kwargs)
        update_content = origin_content
        clz.redis.set(key,json.dumps(update_content))
                      
    @classmethod
    def get_login_user_redis(clz, user_id,kws=[]):
        key = f"{clz.redis_key_prefix}@{user_id}"
        origin_content = clz.redis.get(key)
        if origin_content is None : return {}
        else: content = json.loads(origin_content)
        if kws == []: return content
        response_content = {}
        for kw in kws:
            if kw in content.keys(): response_content[kw] = content[kw]
        return response_content
    
    @classmethod
    def _get_session_from_redis(clz,sess_key=None):
        """"
          the method is usually called by inner class， redis cached the sess_key to backup volatile user_info.
          Alwayse return None if a new sess_key still not cached
        """
        if sess_key is None: sess_key = get_session_key()
        sess = clz.redis.get(sess_key)
        if sess is not None: return json.loads(sess)
        return None
    
    @classmethod
    def _del_session_from_redis(clz,sess_key=None):
        """"
        """
        if sess_key is None: sess_key = get_session_key()
        clz.redis.redis.delete(sess_key)